## 카드 뒤집기 게임

#### 개요

뒤짚인 카드 뭉치에서 짝이 맞는 카드 2장을 고르는 게임입니다!
타입스크립트와 리액트를 이용해서 진행하는 프로젝트입니다

#### 목표 기능

- [x] 매 게임마다 카드의 위치를 임의의 순서로 변경하기
- [x] 선택한 두 장의 카드가 동일할 시, 뒤짚혀진 상태로 유지하기
- [x] 선택한 두 장의 카드가 다를 시, 원래 상태로 돌아가기
- [x] 두 장이 선택되기 전에는 뒤짚혀진 상태에서 기다리기
- [ ] 타이머 기능으로 완료 시간 구하기
- [ ] 게임 종료 시까지 몇 번 클릭한지 표시하기
- [ ] GIT 사용해서 배포 연습해보기

#### 진행 과정

03/18

- 뒤짚혀있는 카드는 클릭되지 않게 단축평가 이용

- open 상태가 변경될 때 랜덤 배치가 되지 않도록 `useMemo`를 사용

03/20

- 카드를 2번 뒤짚을 때마다 서로 같은지 판단해서 후속 동작 진행

- `useEffect` 를 사용해서 리렌더링하게 했는데, useEffect는 필요 없을 것 같다

- `state` 가 변경되면 리렌더링이 진행되므로 두 번 연속 렌더링 되는 문제를 해결해야 한다

- 서로 다른 카드를 클릭했을 때 이전 카드들도 같이 뒤짚이는 현상 해결해야 함

03/21

- 서로 다른 카드를 클릭했을 때 이전 카드들도 같이 뒤짚이는 현상 해결

  이 문제는 `strictMode` 로 인해 렌더링이 **두 번 진행된다는 것** 때문에 발생한 문제였다.
  렌더링이 두 번 발생하니까, `open.pop()` 이 2번씩 2회 진행되기 때문에 이전 카드 쌍도 같이 뒤짚이는 거였다.

  그래서인지 총 2쌍의 카드를 뒤짚은 상태에서 다른 카드를 고르면 1쌍은 정상적으로 남아있게 되었다
  이 문제를 해결하기 위해 `checkRef.current` 값을 이용했다

  `checkRef.current` 는 검증 단계에서 다른 카드 클릭을 막기 위해 사용한 것이였는데, 검증 중에는 `true` 로 저장된다!! 그래서 true일 때는 아무 작업도 이루어지지 않게 해서 해결했다

- 게임 시작 직후 모든 카드를 보여준 뒤에 전체 뒤짚는 기능 추가

  `initRef` 를 이용했는데, 이게 없을 때에는 `setTimeout` 내부에서 `setClick` 을 변경하면
  `checkCard` 함수가 계속 실행됐다. ~~state가 바뀌면 리렌더링이 진행되니까~~

  물론, 리액트는 **Virtual DOM** 이라는 차별화된 기능을 제공하니까 이전과 비교해서 state가 변경되지 않으면 넘어가지만 좋지 않은 코드라고 생각된다.

  그래서 `initRef`가 `false` 일 때만 `checkCard` 함수가 실행하게 조건문을 추가해서 해결했다

03/24

- 변수 이름을 너무 막 지은 것 같다

  `true` 혹은 `false` 로 표현되는 변수는 `is` 를 붙이고, 다른 변수들의 이름도 상태와 동작 여부를 확실히 알 수 있도록 수정했다

03/25

- 처음 카드 전체 뒤짚기에서 `setTimeout()` 은 **클린업**을 해줘야 메모리에 남지 않는다는 것을 알았다

  그런데 클린업을 쓰는 가장 쉽고 좋은 방법은 `useEffect` 를 쓰는 것! 바로 적용했다

- 다시 기억하자. **state가 변경되면 리렌더링이 일어난다!!**

  이건 너무 중요하고 잘 활용해야 하는 부분인 것 같다.

  나는 `setClick` 을 이용해서 리렌더링을 시켰는데, `isInitRender` 값이 변경되면서 리렌더링은 확정이므로 굳이 두 개를 다 사용할 필요가 없다

  그리고 리액트는 가상 DOM을 이용해서 이전 DOM과 달라진 부분만을 렌더링하므로 성능 저하에 영향이 없다

03/28

- 카드를 모두 뒤짚었을 때 모달이 출력되게 구성

- 다시 시작하기 버튼을 클릭했을 때, 페이지 새로고침이 아니라 카드를 다시 뒤짚게 구현

- 해야하는 건 `useMemo` 의 의존성 배열을 수정해서 배열을 섞어주는 과정!

03/29

- `openRef.current ? true : false` 부분을 `!!openRef.current` 로 변경했다

  !!을 두 번 붙여서 해결할 수 있는 이유는 간단하지만 신기했다

  `!` 가 처음 붙었을 때 **피연산자**를 `boolean` 값으로 바꾸고, 반대로 바꾸기 때문이다

  ```javascript
  let number = 2;
  console.log(!number); // false
  console.log(!!number); // true
  ```

  그렇기 때문에 위 코드 블록과 같은 현상이 발생하게 되는 것이다

  결국 원래 피연산자를 boolean 값으로 변경한 결과가 나오게 되는 것

03/30

- `useMemo` 사용하지 않고, `setState` 를 이용해서 첫 렌더링, 클릭 이벤트가 일어났을 때만 배열을 섞어주도록 수정했다

- 초기 게임 환경을 설정하는데 필요한 작업들을 `initGame()` 함수로 통합했다

- `boolean` 혹은 `Number` 처럼 타입스크립트가 쉽게 추론할 수 있는 타입은 굳이 명시해주지 않아도 된다

  그리고 변수나 함수에 마우스를 호버했을 때 타입을 파악할 수 있어야 하거나, 에러났을 때만 타입 써준다고 생각하면 된다

04/03

- `click` 과 `openRef` 로 관리하던 카드 상태를 `selected` 라는 하나의 `state`로 통합하여 관리하도록 코드를 수정했다

  어차피 카드를 클릭할 때마다 리렌더링이 필요하도록 코드를 구성했기 때문에, 굳이 `openRef` 에 배열 상태를 저장할 필요가 없었다

- 동시에 클릭 이벤트 역시 `Game` 컴포넌트에서 선언해서 `Card` 컴포넌트에 `Props` 로 넘겨주었다

  이렇게 하면 `Card` 컴포넌트에 넘겨줘야 하는 `Props` 인자를 줄일 수 있고, 이후 수정이 더 용이하기 때문!
